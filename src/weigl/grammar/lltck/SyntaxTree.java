package weigl.grammar.lltck;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.Map.Entry;
import java.util.regex.Pattern;

import weigl.grammar.ll.rt.AST;
import weigl.grammar.ll.rt.AST.Leaf;
import weigl.grammar.ll.rt.AST.Node;
import weigl.std.collection.Array;

import com.google.common.collect.Multimap;
import com.google.common.collect.TreeMultimap;

/**
 * extracts the information from the parse tree generated by
 * {@link TokenGrammarParser} use {@link #getRules()} and {@link #getTokens()}
 * 
 * @author Alexander Weigl <alexweigl@gmail.com>
 * @date 2010-02-04
 */
@Deprecated
public class SyntaxTree
{

    private Map<String, String>             tokenList = new TreeMap<String, String>();
    private Multimap<String, Array<String>> ruleList  = TreeMultimap.create();

    public SyntaxTree(AST tree)
    {
        Node root = (Node) compress(tree.getRoot());
        recursiveSearch(root);
    }

    /**
     * recursive search for token, rule and file nodes
     * 
     * @param root
     */
    private void recursiveSearch(Node root)
    {
        for (Leaf n : root.getElements())
        {
            if (n.getTerminalSymbol().equals("TOKEN"))
            {
                addToken(n);
            }
            else if (n.getTerminalSymbol().equals("RULE"))
            {
                addRule(n);
            }
            else if (n.getTerminalSymbol().equals("FILE"))
            {
                recursiveSearch((Node) n);
            }
        }
    }

    private void addRule(Leaf n)
    {
        Node m = (Node) n;

        String name = m.getElements().get(0).getTerminalSymbol();
        List<Leaf> rulelist = ((Node) m.getElements().get(2)).getElements();

        for (Leaf l : rulelist)
        {
            Array<String> derivation = parseElement((Node) l);
            ruleList.put(name, derivation);
        }
    }

    private Array<String> parseElement(Node l)
    {
        String[] tokenList = new String[l.getElements().size()];
        int i = 0;
        for (Leaf n : l.getElements())
        {
            String tokenName;
            if (n.hasChildren())// quoted Text
            {
                tokenName = createToken(((Node) n).getElements().get(0).getTerminalSymbol());
            }
            else
            {
                tokenName = n.getTerminalSymbol();
            }
            tokenList[i++] = tokenName;
        }
        return new Array<String>(tokenList);
    }

    private String createToken(String string)
    {
        String tokenName = createTokenName(string, string);
        tokenList.put(tokenName, escapeRegex(string));
        return tokenName;
    }

    private String createTokenName(String name, String regex)
    {
        do
        {
            name = "_" + name.replaceAll("[^a-zA-Z_]", "");
            // till we found a name that does not exists
            // or the name and the regex matches!
        } while (tokenList.containsKey(name) && !!tokenList.get(name).equals(regex));
        return name;
    }

    private String escapeRegex(String pattern)
    {
        // '-2' for removing leading and trailing parens
        return Pattern.quote(pattern.substring(1, pattern.length() - 2));
    }

    private void addToken(Leaf n)
    {
        Node m = (Node) n;
        String name = m.getElements().get(0).getTerminalSymbol();
        String pattern = m.getElements().get(2).getTerminalSymbol();
        tokenList.put(name, pattern);
    }

    /**
     * compress the tree
     * 
     * @param node
     *            the root node
     * @return the new root node
     */
    public static Leaf compress(Node node)
    {
        Leaf n = compressTree(node);
        compressLeaf((Node) n);
        return n;
    }

    /**
     * This method tries to summarize the unary trees under LOWER/ANY/UPPERCASE
     * and QUOTE to a beautiful string<br>
     * This is near some "magic code" <br>
     * 
     * @param node
     * @return
     */
    public static Leaf compressLeaf(Node node)
    {
        List<Leaf> elements = node.getElements();
        List<Leaf> copy = new LinkedList<Leaf>(elements);

        // do for each node
        for (Leaf child : copy)
        {
            if (child.hasChildren())
            {
                Leaf n = compressLeaf((Node) child);
                if (n != null)
                    elements.set(elements.indexOf(child), n);
            }
        }

        if (node.getTerminalSymbol().equals("LOWERCASE")
                        || node.getTerminalSymbol().equals("ANYCASE")
                        || node.getTerminalSymbol().equals("QUOTE")
                        || node.getTerminalSymbol().equals("UPPERCASE"))
        {
            StringBuilder sb = new StringBuilder();

            for (Leaf leaf : elements)
            {
                if (!leaf.hasChildren())
                {
                    sb.append(leaf.getTerminalSymbol());
                }
            }

            elements.clear();
            Leaf l = new Leaf(sb.toString().replace("€", ""));

            if (!node.getTerminalSymbol().equals("QUOTE"))
            {
                return l;
            }
            else
            {
                Node n = new Node("QUOTE");
                n.add(l);
                return n;
            }
        }
        return node;
    }

    /**
     * compress the tree by removing and compacting the tree and nodes
     * 
     * @param node
     * @return
     */
    public static AST.Leaf compressTree(AST.Node node)
    {
        List<Leaf> old = node.getElements();
        List<Leaf> list = new LinkedList<Leaf>(old);

        for (Leaf l : list)
        {
            if (l.hasChildren())
            {
                Leaf child = compressTree((AST.Node) l);
                if (child == null) // if null, then child has no children
                    old.remove(l);
                else
                    // else replace this node by an new node
                    old.set(old.indexOf(l), child);
            }
        }

        if (old.size() >= 2)
        {
            return node;
        }
        else
        {
            if (old.size() == 0)
                return null;
            Leaf child = old.get(0);
            // remove newlines and \n and EPSILONS
            return child.getTerminalSymbol().equals("€")
                            || child.getTerminalSymbol().equals("NEWLINE")
                            || child.getTerminalSymbol().equals("\n") ? null : child;
        }
    }

    /**
     * @return the generated list of token definition
     */
    public List<SynToken> getTokens()
    {
        List<SynToken> l = new LinkedList<SynToken>();
        for (Entry<String, String> e : tokenList.entrySet())
            l.add(new SynToken(e.getKey(), e.getValue(), e.getKey().charAt(0) == '$'));
        return l;
    }

    /**
     * @return the generated list of rule definitions
     */
    public List<SynRule> getRules()
    {
        List<SynRule> rules = new LinkedList<SynRule>();
        for (Entry<String, Collection<Array<String>>> e : ruleList.asMap().entrySet())
        {
            SynRule sr = new SynRule(e.getKey());
            StringBuilder doc = new StringBuilder();
            for (Array<String> a : e.getValue())
            {
                sr.add(a);
                doc.append(sr.getName()).append(" -> ").append(a).append('\n');
            }
            sr.setDoc(doc.toString());
            rules.add(sr);
        }
        return rules;
    }

}
